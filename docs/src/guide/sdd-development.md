# SDD开发

## 概述

SDD（Specification-Driven Development，规范驱动开发）是一种以高质量、结构化的需求规范文档为核心驱动力的软件开发方法论。它将传统“先写代码再补文档”的流程反转，强调 “先定义清楚做什么，再决定怎么做，最后自动生成实现”。

## 核心理念
- 规范即代码”（Specification as Code）
- 将需求、设计、验收标准等以机器可读、AI可理解的格式编写
- 规范文档不仅是沟通工具，更是生成代码的输入源
- 开发者角色从“编码者”转变为“规范定义者 + 质量把控者”
- **设计先行**: 以设计稿为起点，确保UI/UX的一致性
- **组件化思维**: 基于微组件库构建，提高代码复用率
- **规范统一**: 统一的设计规范和开发规范，降低维护成本
- **快速迭代**: 缩短从设计到上线的时间周期

## SDD 与传统开发模式对比

SDD（规范驱动开发）与传统开发模式在多个维度上存在显著差异：

| 维度 | 传统开发 | SDD（规范驱动开发） |
|------|---------|-------------------|
| 起点 | 模糊需求 → 直接编码 | 清晰规范 → 自动生成代码 |
| 文档地位 | 事后补充，常滞后或缺失 | 核心资产，驱动整个流程 |
| 开发者重心 | 写代码、调 Bug | 定义需求、审查规范、验证结果 |
| AI 角色 | 辅助补全 | 主力执行者（基于规范生成实现） |
| 迭代方式 | 修改代码 → 测试 → 修复 | 修改规范 → 重新生成 → 验证 |

### 对比分析

#### 1. 开发起点
- **传统开发**：往往基于模糊的需求直接开始编码，导致频繁返工
- **SDD 开发**：先建立清晰的规范文档，再基于规范生成代码，减少返工

#### 2. 文档地位
- **传统开发**：文档往往是事后补充，容易滞后甚至缺失
- **SDD 开发**：文档是核心资产，整个开发流程由文档驱动

#### 3. 开发者角色转变
- **传统开发**：开发者主要精力在写代码和调试 Bug
- **SDD 开发**：开发者专注于定义需求、审查规范、验证 AI 生成的结果

#### 4. AI 的作用
- **传统开发**：AI 仅作为代码补全辅助工具
- **SDD 开发**：AI 是主力执行者，基于规范自动生成高质量代码

#### 5. 迭代效率
- **传统开发**：修改代码、测试、修复，周期长
- **SDD 开发**：修改规范文档，重新生成代码，快速验证

## 组件库

MicroAdmin 提供完整的组件库支持：

### 基础组件
- 按钮、输入框、选择器等常用表单组件
- 表格、树形控件、标签页等数据展示组件
- 弹窗、抽屉、消息提示等交互组件

### 业务组件
- 表单生成器
- 搜索组件
- 操作按钮组
- 数据字典选择器

### 布局组件
- 页面容器
- 卡片容器
- 分割面板

## SDD 开发流程

SDD 开发采用标准化的 8 步流程，确保需求清晰、设计合理、代码高质量。

| 步骤 | 命令 | 输出 | 说明 |
|------|------|------|------|
| 0. 项目章程 | `/speckit-constitution` | `constitution.md` | 定义技术栈约束、安全策略、编码规范、架构原则，相当于项目的"宪法" |
| 1. 功能规范 | `/speckit-specify` | `spec.md` | 用自然语言描述用户故事、业务规则、验收标准、回答“要做什么？”明确功能目标、验收标准 |
| 2. 需求澄清 | `/speckit-clarify` | 更新 `spec.md` | 针对不清晰的地方提问，AI识别模糊点，补充边界条件，消除歧义，提升规范的精确性和完整性 |
| 3. 技术方案 | `/speckit-plan` | `plan.md` | 接口设计、数据模型，制定架构设计、API 接口、数据库模型、技术选型，回答"怎么做？" |
| 4. 完整性检查 | `/speckit-checklist` | `checklist.md` | 检查遗漏场景 |
| 5. 任务拆解 | `/speckit-tasks` | `tasks.md` | 拆成可执行任务，将方案分解为原子级、可并行的开发任务，每个任务含明确验收条件 |
| 6. 一致性分析 | `/speckit-analyze` | 分析报告 | 确保文档一致 |
| 7. 自动实现 | `/speckit-implement` | 代码 + 文档 | 逐任务实现，AI 自动执行任务：生成代码、测试、运行命令、代码审查支持一键重试和上下文修复 |

### 流程详解

#### 步骤 0: 项目章程

使用 `/speckit-constitution` 命令，生成 `constitution.md` 文件，定义项目的基础约束和规范：

- **技术栈约束**：规定允许使用的技术栈和框架，禁止使用的技术
- **安全策略**：数据加密、身份认证、权限控制、日志审计等安全要求
- **编码规范**：命名规范、代码风格、注释规范、文件组织结构
- **架构原则**：分层架构、模块化设计、依赖倒置、单一职责等设计原则
- **开发流程**：Git 分支策略、代码审查流程、CI/CD 流程
- **质量标准**：代码覆盖率、性能指标、兼容性要求

项目章程是整个开发的基础，相当于项目的"宪法"，所有后续开发都应遵循。

#### 步骤 1: 需求规格化

使用 `/speckit-specify` 命令，生成 `spec.md` 文件，明确：

- 功能目标和用户需求
- 验收标准和成功指标
- 技术约束和依赖项
- 交付物清单

#### 步骤 2: 需求澄清

使用 `/speckit-clarify` 命令，针对需求中的不清晰点进行提问：

- 边界条件和异常处理
- 性能和安全要求
- 兼容性和可扩展性需求
- 更新 `spec.md` 文档

#### 步骤 3: 技术规划

使用 `/speckit-plan` 命令，生成 `plan.md` 文件，包含：

- 接口设计（API 契约）
- 数据模型设计
- 架构设计和技术选型
- 数据库设计

#### 步骤 4: 完整性检查

使用 `/speckit-checklist` 命令，生成 `checklist.md`，检查：

- 功能覆盖度
- 异常场景处理
- 边界条件考虑
- 安全性检查

#### 步骤 5: 任务拆解

使用 `/speckit-tasks` 命令，生成 `tasks.md`，将需求拆解为：

- 前端开发任务
- 后端开发任务
- 测试任务
- 部署任务

#### 步骤 6: 一致性分析

使用 `/speckit-analyze` 命令，生成一致性分析报告：

- 文档间一致性
- 接口与实现一致性
- 需求与测试一致性
- 识别潜在问题

#### 步骤 7: 实施执行

使用 `/speckit-implement` 命令，执行开发：

- 按任务列表逐项实现
- 生成代码和文档
- 自动化测试
- 代码审查

## SDD 的关键优势

SDD 开发模式相比传统开发具有以下核心优势：

- ✅ **减少认知负荷**：开发者无需记忆细节，专注逻辑定义
- ✅ **提升一致性**：规范统一，避免"各写各的"风格混乱
- ✅ **加速交付**：AI 并行生成多文件代码，效率倍增
- ✅ **降低缺陷率**：规范先行，边界条件提前考虑
- ✅ **知识沉淀**：规范文档即项目知识库，便于交接维护

### 优势详解

#### 1. 减少认知负荷
传统开发需要开发者记忆大量实现细节，SDD 将注意力转移到逻辑定义，降低记忆负担。

#### 2. 提升一致性
统一规范确保团队所有成员生成代码风格一致，避免代码风格混乱。

#### 3. 加速交付
AI 可以并行生成多个文件，大幅提升开发速度，缩短交付周期。

#### 4. 降低缺陷率
通过规范先行的方式，在编码前就考虑边界条件和异常场景，减少 Bug。

#### 5. 知识沉淀
规范文档成为项目知识库，新人快速上手，项目交接更顺畅。

## 适用场景

### 适用场景

- ✅ **新项目从零启动**（最佳实践）
- ✅ **功能模块重构**（先写新规范，再生成新实现）
- ✅ **需求明确但实现复杂的系统**（如数据看板、表单引擎）
- ✅ **团队协作开发**（统一规范 = 统一理解）

### 不适用场景

- ⚠️ **探索性原型**：需求不明确，需要快速试错
- ⚠️ **算法研究**：需要大量实验和调试
- ⚠️ **高度依赖人工调试的图形/音视频处理**：需要精细调优

## 典型工具支持

### 1. Spec Kit
GitHub 官方推出的规范管理工具，提供 `/speckit.xxx` 系列命令，支持：
- 规范文档生成
- 需求分析
- 任务拆解
- 代码生成

### 2. AI 编程助手
可作为 SDD 的执行引擎：
- **Claude**：强大的代码生成和推理能力
- **Copilot**：GitHub 官方 AI 助手
- **Cursor**：专注于代码编辑的 AI 助手
- **Gemini**：Google 的多模态 AI

### 3. IDE 集成
主流编辑器均支持 SDD 工作流：
- **VS Code**：丰富的插件生态，支持多种 AI 助手
- **JetBrains 系列**：IntelliJ IDEA、WebStorm 等
- **其他编辑器**：Vim、Neovim 等

## 开发流程

### 1. 设计稿准备

```bash
# 导出设计资源
- 图标资源
- 图片资源
- 配色方案
- 字体规范
```

### 2. 页面搭建

使用 Vue3 + Element-Plus + UnoCSS 快速搭建页面：

```vue
<template>
  <micro-page title="页面标题">
    <micro-card>
      <!-- 页面内容 -->
    </micro-card>
  </micro-page>
</template>

<script setup lang="ts">
// 页面逻辑
</script>
```

### 3. 组件使用

```typescript
import { MicroButton, MicroTable, MicroForm } from '@micro/components'

// 直接使用组件
```

## 代码生成

### 使用代码生成器

1. 配置数据表信息
2. 选择生成模板
3. 一键生成前后端代码

生成内容包括：
- Vue 页面组件
- API 接口
- 类型定义
- 路由配置

## 最佳实践

### 1. 命名规范

```typescript
// 组件命名
PascalCase: UserList.vue

// 文件命名
kebab-case: user-list.ts

// 变量命名
camelCase: userName
```

### 2. 组件封装

```vue
<script setup lang="ts">
// 使用 defineProps 定义接口
interface Props {
  data: User[]
  loading?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  loading: false
})
</script>
```

### 3. 类型安全

```typescript
// 使用 TypeScript 类型定义
interface User {
  id: number
  name: string
  email: string
}

// API 返回类型
type ApiResponse<T> = {
  code: number
  data: T
  message: string
}
```

## 规范文档

详见：
- [代码规范](./use-icons.md)
- [目录结构](./directory-structure.md)
- [权限控制](./permission-control.md)

## 相关链接

- [组件库文档](https://github.com/micro-components/micro-design-admin)
